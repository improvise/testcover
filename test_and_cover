#!/your/virtualenv/python/here

# Runs all unit tests in files matching (test_*.py) and checks branch coverage
# Only output when test failed or coverage incomplete

# Author: Steven Liao (dev+github@stevenliao.net)
# License: BSD (3-clause) license (See LICENSE)


import os
import subprocess
import sys


def check_test_files():
    test_filenames = _get_test_filenames()
    if len(test_filenames) == 0:
        print "No tests found (tests need to be named test_*.py)."
        sys.exit(1)
    else:
        old_pyc_filenames = _get_pyc_filenames()
        num_problems = sum((1 for filename in test_filenames
            if not _tests_passed(filename) or not _coverage_complete()))
        _remove_new_pyc_files(old_pyc_filenames)
        sys.exit(1 if num_problems > 0 else 0)


def _get_test_filenames():
    return [fname for fname in _cwd() if _is_unittest_file(fname)]


def _is_unittest_file(filename):
    return filename.startswith("test_") and filename.endswith(".py")


def _cwd():
    return os.listdir(".")


def _get_pyc_filenames():
    return [fname for fname in _cwd() if fname.endswith(".pyc")]


def _tests_passed(filename):
    test_out = subprocess.check_output(
        ["coverage", "run", "--branch", filename],
        stderr=subprocess.STDOUT
    )
    if _tests_output_passed(test_out):
        return True
    else:
        print test_out
        return False


def _tests_output_passed(test_out):
    return test_out.split('\n')[-2] == 'OK'


def _coverage_complete():
    coverage_out = subprocess.check_output(["coverage", "report", "-m"])
    if _coverage_output_complete(coverage_out):
        return True
    else:
        print coverage_out
        return False


def _coverage_output_complete(coverage_out):
    return sum([
            1 for line in coverage_out.split('\n')
                if _is_class(line) and not _is_line_covered(line)
        ]) == 0


def _is_class(coverage_out_line):
    return "%" in coverage_out_line


def _is_line_covered(coverage_out_line):
    return "100%" in coverage_out_line


def _remove_new_pyc_files(old_pyc_filenames):
    all_pyc_filenames = _get_pyc_filenames()
    new_pyc_filenames = list(set(all_pyc_filenames) - set(old_pyc_filenames))
    for pyc_filename in new_pyc_filenames:
        os.remove(pyc_filename)


check_test_files()
